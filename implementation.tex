Implementaci rozdělíme na 2 části a to na část zabívající se backendem, tedy mozkem naší aplikace, která bude zodpovídat
za ukladání a zpracování dat, bude nám také sloužit jako autentifikační server. A poté na frontend, tedy část, která
je zodpovědné za komunikaci s backendem a také bude zpostředkovávat zobrazení dat z backendu uživateli.

\section{Backend}

Jako základ backendu máme Flask, \uv{což je mikroframework pro Python\linebreak založený na Werkzeug, Jinja 2 a dobrých záměrů.} \cite{flaskDoc}
Tento mikroframework nabízí vytváření stránek ve formátu \gls{html}, toto ovšem nebude třeba, \mbox{neboť} celý backend je složen pouze z \gls{rest} metod,
které slouží k získání či úpravě dat. Konkrétně použijeme HTTP metody GET, POST a DELETE, které provedou určitou akci na základě volané adresy.
Pro další funkcnionality\linebreak využíváme v mnoha případech moduly, které rozšižují základní Flask.

\subsection{Ověřování uživatele}

V rámci ověřovaní uživatelů musíme zajistit zabezpečenou komunikaci mezi backendem a frontendem. Toho docílíme sdílením tokenu, který bude ověřovat
každý dotaz do té části aplikace, kam mají přístup pouze přihlášení uživatelé. Toho docílíme pomocí modulu, který rožšiřujeme Flask,
\textit{Flask-jwt-extended}. Pro správnou funkci tohoto modulu je třeba mít nastavený tajný klíč pro aplikaci, který slouží k šifrování \gls{jwt},
ve kterém se nachází identifikátor uživatele. Dále je potřeba definovat funkce pro načítání uživatele a jeho rolí, toto bude poté použito pro kontrolu
oprávnění uživatele a získávání dat, která jsou vázána na uživatele, zde je ukázka \ref{lst:flaskJWTCode}.

\begin{listing}
    \begin{minted}{python}
        # File: moddoc/service/auth_service.py

        @app.jwt.user_claims_loader
        def add_claims(user):
            """
            Load claims into JWT
            """
            return {'roles': user['roles']}

        @app.jwt.user_identity_loader
        def load_user(user):
            """
            Function for loading user
            """
            return user
    \end{minted}
    \caption{Ukázka kódu pro \textit{Flask-jwt-extended}}
    \label{lst:flaskJWTCode}
\end{listing}

\subsection{Propojení s databází}

Na toto použijeme další rozšíření pro \textit{Flask} a to konkrétně \textit{Flask-SQLAlchemy}, jedná se interpretaci \textit{SQLAlchemy}, což je \gls{orm} nástroj pro Python.
Podporuje většinu \gls{sql} implementací a serverů. V našem případě budeme brát \textit{postgresql} jako nejvhodnější jazyk a databázový server se zaručenou podporou pro \textit{sqlite}. Protože
v aplikaci používáme jako identifikátor všech modelů používáme \gls{guid}, základní implementace \textit{SQLAlchemy} nám ovšem tento datový typ nativně nepodporuje, stejně jako
některé \gls{sql} servery. Proto si vytvoříme vlastní datový typ \gls{guid}, ukázku jak na to nalezeme i v oficiální dokumentaci \textit{SQLAlchemy} \cite{sqlalchemyGuid}. Jak lze
vidět v ukázce kódu \ref{lst:guidImplementation}, při vytváření tohoto typu je provedena kontrola, na s jakou databází bude aplikace pracovat a podle toho se rozhodne jaký datový typ
bude v rámci databáze použit. Toto se provádí protože ne všechny databáze si umí poradit s GUID datovým formátem.

\begin{listing}
    \begin{minted}{python}
        from sqlalchemy.types import TypeDecorator, CHAR
        from sqlalchemy.dialects.postgresql import UUID
        import uuid

        class GUID(TypeDecorator):
            """Platform-independent GUID type.

            Uses PostgreSQL's UUID type, otherwise uses
            CHAR(32), storing as stringified hex values.

            """
            impl = CHAR

            def load_dialect_impl(self, dialect):
                if dialect.name == 'postgresql':
                    return dialect.type_descriptor(UUID())
                else:
                    return dialect.type_descriptor(CHAR(32))

            def process_bind_param(self, value, dialect):
                if value is None:
                    return value
                elif dialect.name == 'postgresql':
                    return str(value)
                else:
                    if not isinstance(value, uuid.UUID):
                        return "%.32x" % uuid.UUID(value).int
                    else:
                        # hexstring
                        return "%.32x" % value.int

            def process_result_value(self, value, dialect):
                if value is None:
                    return value
                else:
                    if not isinstance(value, uuid.UUID):
                        value = uuid.UUID(value)
                    return value
    \end{minted}
    \caption{Implementace GUID datového typu}
    \label{lst:guidImplementation}
\end{listing}

\clearpage

\subsection{Kontrola příchozích dat}

Jako v každém programu je potřeba kontrolovat vstupní data, je i v našem případě nutné kontrolovat data, která přijdou z našeho\linebreak frontendu, nebo například z mobilní aplikace,
která se bude připojovat na náš backend. Pro kontrolu dat použijeme implementaci schémat z dalšího modulu pro Python, \textit{marshmallow}. Tento modul nám umožní definovat
nejen formát dat, ale také definuje formát výstupních dat, která budou načtena přímo z~výstupu dotazu nebo objektu z~\textit{SQLAlchemy}.

\section{Frontend}

Základním stavebním kamenem frontendu je knihovna React psaná v JavaScriptu. Tato knihovna nám zajištuje základ pro vytváření webového grafického rozhraní. React rozděluje
jednotlivé prvky z rozhraní do komponent, které se poté dají kombinovat, znovu využívat a dá se u nich definovat\linebreak rozšiřující chování. Na psaní v Reactu není potřeba psaní
si vlastních šablon, vše je psáno přímo v JavaScriptovém kódu. \cite{reactJS} Samotný React ještě rozšíříme o~další důležité knihovny.

\subsection{Redux}

Tím asi nejdůležitějším rozšířením Reactu v této práci je knihovna Redux. Redux je, stejně jako React, také knihovna pro JavaScript. Jeho hlavní funkcí je
ukládání si stavů aplikace, tudíž je možné předem nadefinovat všechny stavy, ve kterých se naše aplikace může objevit a není problém se pohybovat na časové
díky této vlastnosti. Je dobré podotknout, že tyto stavy jsou perzistentní. Pro propojení s Reactem existuje knihovna React-Redux přímo od vývojářů Reduxu. \cite{redux}

\subsection{Reactstrap}

Pro frontend je táké důležité, aby všechny ovládácí prvky byly stejné a celá aplikace měla jednotný design. Reactstrap je knihovna rozšiřující React o komponenty,
které jsou již nastylované a to za použití Bootstrap stylů. Tyto komponenty jsou poté použity v celé aplikaci a díky Bootstrapu nemusíme vytvářet vlastní styly,
pokud si vystačíme s tím, co nám nábízí Bootstrap.

\subsection{Struktura aplikace}

Aby se při vytváření aplikace dalo snáze orientovat v již napsaném kódu, investujeme chvilku času do definování a vytvoření adresářové struktury. Ta nám
pomůže jednoduše určit, kde se nacházejí jednotlivé části aplikace, je třeba dobré rozdělit části týkající se pouze Reduxu do vlastní složky, či je dobré roztřídit
jednotlivé komponenty podle toho, které části aplikace se týkají.
